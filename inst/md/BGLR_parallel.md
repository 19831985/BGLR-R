### Running multiple parallel chains with BGLR

In the followin entry we discuss two approaches for running parallel chains in BGLR. The first one is the estanard approach where multiple parallel calls to BGLR() are made. We presenten the example using the parallel package. For computationally involved problems this approach can be inefficient; thefore we introduce a 2nd approach that involves modifications of the BGLR software.

#### Running parallel chains with BGLR I

 First we need a wrapper for BGLR that will set the seed of the RGN to a user-specified value
 
```R
  BGLR.wrap=function(seed,...){
	  set.seed(seed)
	  fileName=paste0('seed_',seed,'_')
	  fm=BGLR(...,saveAt=fileName)
	  return(list(fm=fm,seed=seed))
  }
```

Now we can call BGLR in parallel at multiple cores using the parallel package.

```R
 library(parallel)
 library(BGLR)
 data(wheat)
 X=scale(wheat.X)
 y=wheat.Y[,1]
 
 seeds=c(100,200,300,400)
 ETA=list(list(X=X,model='BRR'))
 fmList=mclapply(FUN=BGLR.wrap,X=seeds,mc.cores=4,y=y,ETA=ETA,nIter=6000,burnIn=1000,verbose=F)
 list.files()
 
 # Adding name to the list (the seed used is the  name)
  tmp=rep(NA,length(fmList))
  for(i in 1:length(fmList)){ tmp[i]=fmList[[i]]$seed }
  names(fmList)=tmp
```

**Note 1**: Unfortounately we are gettin an error if saveEffects=TRUE, this needs to be further explored.

**Note 2**: Above we we illustrate how to run parallel chains. I this case the argument that changes across processes is the seed.
However, any aspect of the run may change. For instance, ``BGLR.wrap`` may have as an argument the prior to be used; in such case ``BGLR.wrap`` can be modified so that each processor fits the model with one prior.


#### Rnning parallel chains with BGLR II


For problems involving large number of predictors and large number of subjects the time per itearation of the sampler may be large (e.g, a ccouple of seconds)
and running long chains may take too much time. In these cases, and especially when one has acces to a computing cluster, running multiple parallel short chains
may be a better option than runnin a single long chain. 

However, in big problems the burn-in period can be large. This can be overcomed if one uses as initial values samples generated by another
chain collected after burn in. Before the Gibbs sampler starts BGLR carries out many computations that make the sampler more effient. These
computations also take some time that can be saved if we were able to 'recycle' the results from these computations from a previous run.

To achieve this goal we propose to modify BGLR in a very simple way, we will modify BGLR so that:  

  - if specified by the user, the program can save the environment,
  - if the call provides a filename for an environment, BGLR will load the environment and start the gibbs sampler.
          
Conceptually, the BGLR code can be divided in the following blocks of code

```
   BGLR=function(args...){
    #1# Preliminary computations and initialization
      ...
    #2# Sampling, saving samples and updateing running means
      ...
    #3# Coputation of posterior means and preparation of outputs
      ...
    #4# Return
   }
```

We will modify BGLR by:
  - adding two new inputs (envIn=NULL and envOut=NULL, both characters) that will specify filenames that can be used to load (envIn) or save (envOut) an environment.
  - If envIn is not null, then, the first block of code will be skipped
  - If envOut is not null, between #2# and #3# we will insert code to save the environment.

This modifications will allow users to call BGLR from a saved environment. These are examples of typical calls and the expected behavior:

```R
  # standard call no environment is loaded/saved
   BGLR(y,...) 
  
  # calls BGLR, runs, saves the environment and returns..
   BGLR(y,..., envOut='filename.RData') 
   
  # loads envIn and runs the specified iterations.
   BGLR(envIn='filename.RData', nIter=,...) 
  
  # loads inputFile.RData, runs the sampler, saves the environment and reutnrs.
   BGLR(evnIn='inputFifle.RData', envOut='outputFile.Rdata', nIter=....) 
```
**Important Details**   
  - The arguments nIter, burnIn, thin and saveAt provided by the user in the call must override the ones contains in envIn
  - Before the xampler starts, all the connections to files needs to be opened with the appropiate filenames (using saveAt provided by the user)
  - 
