### Running multiple parallel chains with BGLR

In the following entry we discuss two approaches for running BGLR in parallel. The first one is a stanard approach where multiple parallel calls to BGLR() are made using the function `mclapply()` of the `parallel` package. Using this approach we demonstrate: (i) ho to run parallel chains and (ii) cross-validation in parallel. The second approach is tailored for computationally involved problems (*big-n-with-big-p* problems) and is design for execution in clusters.


**1) Multi-core computing with BGLR using the parallel package**

**1.1) Parallel chains**
 
 First we need a wrapper for BGLR that will set the seed of the RGN to a user-specified value
 
```R
  BGLR.wrap=function(seed,...){
	  set.seed(seed)
	  fileName=paste0('seed_',seed,'_')
	  fm=BGLR(...,saveAt=fileName)
	  return(list(fm=fm,seed=seed))
  }
```

Now we can call BGLR in parallel at multiple cores using the parallel package.

```R
 library(parallel)
 library(BGLR)
 data(wheat)
 X=scale(wheat.X)
 y=wheat.Y[,1]
 
 seeds=c(100,200,300,400)
 ETA=list(list(X=X,model='BRR',saveEffects=TRUE))
 fmList=mclapply(FUN=BGLR.wrap,X=seeds,mc.cores=4,y=y,ETA=ETA,nIter=6000,burnIn=1000,verbose=F)
 list.files()
 
 # Adding name to the list (the seed used is the  name)
  tmp=rep(NA,length(fmList))
  for(i in 1:length(fmList)){ tmp[i]=fmList[[i]]$seed }
  names(fmList)=tmp
```

**1.2) Cross-validation at multiple cores**

Wrapper

```R
  BGLR.fold=function(fold,folds,...){
	tst=which(folds==fold)
	y[tst]=NA
	
	fm=BGLR(...,saveAt=paste0('fold_',fold))
	yHat=fm$yHat[tst]
	if(is.null(names(y))){
		names(yHat)=tst
	}else{
		names(yHat)=names(y)[tst]	
	}
	return(list(fm=fm,yHat=yHat))
  }
```

Execution

```R
  library(BGLR)
  data(wheat)
  y=wheat.Y[,1]
  X=scale(wheat.X)
  folds=sample(1:5,size=length(y),replace=T)
  ETA=list(list(X=X,model='BayesA'))
  fmList=mclapply(FUN=BGLR.fold,X=1:5,folds=folds,ETA=ETA,nIter=6000,burnIn=1000)
  
```

**Runing parallel chains with BGLR in a cluster **


For problems involving large number of predictors and large number of subjects the time per itearation of the sampler may be large (e.g, a ccouple of seconds)
and running long chains may take too much time. In these cases, and especially when one has acces to a computing cluster, running multiple parallel short chains
may be a better option than runnin a single long chain. 

However, in big problems the burn-in period can be large. This can be overcomed if one uses as initial values samples generated by another
chain collected after burn in. Before the Gibbs sampler starts BGLR carries out many computations that make the sampler more effient. These
computations also take some time that can be saved if we were able to 'recycle' the results from these computations from a previous run.

To achieve this goal we propose to modify BGLR in a very simple way, we will modify BGLR so that:  

  - if specified by the user, the program can save the environment,
  - if the call provides a filename for an environment, BGLR will load the environment and start the gibbs sampler.
          
Conceptually, the BGLR code can be divided in the following blocks of code

```
   BGLR=function(args...){
    #1# Preliminary computations and initialization
      ...
    #2# Sampling, saving samples and updateing running means
      ...
    #3# Coputation of posterior means and preparation of outputs
      ...
    #4# Return
   }
```

We will modify BGLR by:
  - adding two new inputs (envIn=NULL and envOut=NULL, both characters) that will specify filenames that can be used to load (envIn) or save (envOut) an environment.
  - If envIn is not null, then, the first block of code will be skipped
  - If envOut is not null, between #2# and #3# we will insert code to save the environment.

This modifications will allow users to call BGLR from a saved environment. These are examples of typical calls and the expected behavior:

```R
  # standard call no environment is loaded/saved
   BGLR(y,...) 
  
  # calls BGLR, runs, saves the environment and returns..
   BGLR(y,..., envOut='filename.RData') 
   
  # loads envIn and runs the specified iterations.
   BGLR(envIn='filename.RData', nIter=,...) 
  
  # loads inputFile.RData, runs the sampler, saves the environment and reutnrs.
   BGLR(evnIn='inputFifle.RData', envOut='outputFile.Rdata', nIter=....) 
```
**Important Details**   
  - The arguments nIter, burnIn, thin and saveAt provided by the user in the call must override the ones contains in envIn
  - Before the xampler starts, all the connections to files needs to be opened with the appropiate filenames (using saveAt provided by the user)
  - 
