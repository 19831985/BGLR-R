### Running multiple parallel chains with BGLR

In the followin entry we discuss two approaches for running parallel chains in BGLR. The first one is the estanard approach where multiple parallel calls to BGLR() are made. We presenten the example using the parallel package. For computationally involved problems this approach can be inefficient; thefore we introduce a 2nd approach that involves modifications of the BGLR software.

#### Running parallel chains with BGLR I


```R
  myF=function(nIter,seed){
    set.seed(seed)
    samples=rnorm(nIter)
    return(list(seed=seed,samples=samples))
  }
  
  seeds=sample(100:200,size=4)
  tmp=mclapply(FUN=myF,mc.cores=4,nIter=100,X=seeds)
  
  for(i in 1:4) {set.seed(seeds[i]);x=rnorm(100); print(all.equal(x,tmp[[i]]$samples))}
  
  
```
#### Rnning parallel chains with BGLR II


For problems involving large number of predictors and large number of subjects the time per itearation of the sampler may be large (e.g, a ccouple of seconds)
and running long chains may take too much time. In these cases, and especially when one has acces to a computing cluster, running multiple parallel short chains
may be a better option than runnin a single long chain. 

However, in big problems the burn-in period can be large. This can be overcomed if one uses as initial values samples generated by another
chain collected after burn in. Before the Gibbs sampler starts BGLR carries out many computations that make the sampler more effient. These
computations also take some time that can be saved if we were able to 'recycle' the results from these computations from a previous run.

To achieve this goal we propose to modify BGLR in a very simple way, we will modify BGLR so that:  

  - if specified by the user, the program can save the environment,
  - if the call provides a filename for an environment, BGLR will load the environment and start the gibbs sampler.
          
Conceptually, the BGLR code can be divided in the following blocks of code

```
   BGLR=function(args...){
    #1# Preliminary computations and initialization
      ...
    #2# Sampling, saving samples and updateing running means
      ...
    #3# Coputation of posterior means and preparation of outputs
      ...
    #4# Return
   }
```

We will modify BGLR by:
  - adding two new inputs (envIn=NULL and envOut=NULL, both characters) that will specify filenames that can be used to load (envIn) or save (envOut) an environment.
  - If envIn is not null, then, the first block of code will be skipped
  - If envOut is not null, between #2# and #3# we will insert code to save the environment.

This modifications will allow users to call BGLR from a saved environment. These are examples of typical calls and the expected behavior:

```R
  # standard call no environment is loaded/saved
   BGLR(y,...) 
  
  # calls BGLR, runs, saves the environment and returns..
   BGLR(y,..., envOut='filename.RData') 
   
  # loads envIn and runs the specified iterations.
   BGLR(envIn='filename.RData', nIter=,...) 
  
  # loads inputFile.RData, runs the sampler, saves the environment and reutnrs.
   BGLR(evnIn='inputFifle.RData', envOut='outputFile.Rdata', nIter=....) 
```
**Important Details**   
  - The arguments nIter, burnIn, thin and saveAt provided by the user in the call must override the ones contains in envIn
  - Before the xampler starts, all the connections to files needs to be opened with the appropiate filenames (using saveAt provided by the user)
  - 
